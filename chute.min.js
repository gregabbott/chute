/*https://gregabbott.github.io/chute By + (C) Greg Abbott 2024. V: 2024-12-07.1*/
const chute=(()=>{const t=(...t)=>{throw new Error(t)},e=t=>t instanceof Function,a=t=>Array.isArray(t),n=t=>t&&"object"==typeof t&&!Array.isArray(t),i=t=>e=>{for(let a in e)if(!1===t(a,e[a],e))break},r={},l={},o=(a,...n)=>function({seed:a,args:n}){let i={data:null,fns_seen:{},with_received:!1,sync_data:null,skip_void:!0};i.keep=function(t){return a=>{let n=a.name;return n&&!e(globalThis[n])&&!t.fns_seen[n]&&(t.fns_seen[n]=a),a}}(i),i.set_data=t=>{i.skip_void&&void 0===t||(i.sync_data&&i.sync_data(t),i.data=t)},i.get_data=()=>i.data,i.set_data(a),n.length>0&&i.set_data(r.do({args:n,data:a,a_chute:i}));const l=[];function s(t,e){return l.push(e),c}function d(a,n,s){let d=["_end","_$"].includes(l.at(-1));d&&l.pop();let f=0==l.length,g=f&&s.length>0,p=f&&0===s.length,b=l.length>0,v=p||d;return g&&i.set_data(r.do({args:s,data:i.get_data(),a_chute:i})),b&&i.set_data(function({keys:a,args:n,a_chute:i,chute_lib:r}){let l=i.get_data(),s=i.skip_void;function d(e,a){let n="a built in chute method, a method of the_current_data, a global function, a function passed in to this chute via a previous call, or Chute's .feed or .lift properties";if(r.hasOwnProperty(e))return["chute_lib",r];if(null!==a.data&&void 0!==a.data[e])return["the_current_data",a.data];if(i.fns_seen[e])return["memoized_function",i.fns_seen];if(o.library[e])return["Feed_lib",o.library];let l=o.lifted_libraries.find((t=>t[e]));return l?["Lift_lib",l]:void 0!==globalThis[e]?["global_this",globalThis]:void t(`"${e}" is not: ${n}`)}return a.reduce(((t,e,i,r)=>{if(t.path||([t.root_string,t.root]=d(e,t),t.path=t.root,t.context=t.root),t.path=t.path[e],i==r.length-1)return c({fn:t.path,key:e,a:t,args:n});let l=a[i+1];return void 0===t.path[l]&&(t.data=c({fn:t.path,key:e,a:t}),t.path=null),t.context=t.path,t}),{path:null,data:l,context:null,root:null});function c({fn:a,key:n,a:l,args:d=[]}){let c;return e(l.path)||t(`${l.root_string}'s â€¦ "${n}" is not a FN`),l.root==r?c=a({args:d,data:l.data,a_chute:i}):l.root===globalThis||l.root==i.fns_seen||l.root==o.library||"Lift_lib"==l.root_string?c=u({fn:a,data:l.data,args:d}):(c=a.call(l.context,...h(d,l.data)),c=_.has(n)?l.data:c),s&&void 0===c?l.data:c}}({keys:l,a_chute:i,args:s,chute_lib:r})),l.length=0,v?i.get_data():c}let c=new Proxy((()=>{}),{get:s,apply:d});return c}({seed:a,args:n});o.x=l,o.library={},o.lifted_libraries=[];const s=(t,e)=>{n(e)&&(o.library[t]=e,o.lifted_libraries.push(e))};function d(e){n(e)||t("give .lift 1 object"),i(s)(e)}o.lift=d;const c=(t,a)=>{(e(a)||n(a))&&(o.library[t]=a)};function f(e){n(e)||t("feed accepts an objects"),i(c)(e)}o.feed=f,r.log=({args:t,data:e})=>(t.length>0?console.log(...t,e):console.log(e),e),r.do=({args:a,data:n,a_chute:i})=>(0==a.length&&t(".do needs 1+ arguments"),a.reduce(((t,a)=>"log"===a?(console.log(t),t):e(a)?(i.keep(a),a(t)):a),n));const u=({fn:t,data:e,args:a})=>{if(0===a.length)return t(e);let n=h(a,e);return n!==a?t(...n):t(...a)(e)},h=(t,e)=>t.length>0&&t.includes(l)?t.map((t=>t===l?e:t)):t,_=new Set(["forEach","push","unshift"]);r.if=({args:i,data:r,a_chute:l})=>{0==i.length&&t(".if needs 1-2 arguments");let o=2===i.length?{if:i}:1===i.length&&i[0];if(function(t){if(!n(t))return!1;if(!1 in t)return!1;const e=t=>a(t)&&2===t.length&&0 in t&&1 in t;let i=Object.entries(t).reduce(((t,[n,i])=>("if"==n&&a(i)&&e(i)?t.valid[n]=i:"else_if"==n?t[a(i)&&i.map(e).filter((t=>!t)).length<1?"valid":"invalid"][n]=i:"else"==n?t.valid[n]=i:t.invalid[n]=i,t)),{valid:{},invalid:{}});return 0===Object.keys(i.invalid).length}(o)){let t=function(t,a,n){function i({condition:t,data:a}){return e(t)?t(a):t}if((t.else_if?[t.if,...t.else_if]:[t.if]).forEach((([t,a])=>{e(t)&&n.keep(t),e(a)&&n.keep(a)})),i({condition:t.if[0],data:a}))return t.if[1];if("else_if"in t)for(const[e,n]of t.else_if)if(i({condition:e,data:a}))return n;return"else"in t?(e(t.else)&&n.keep(t.else),t.else):a}(o,r,l);return r===t?r:e(t)?u({fn:t,data:r,args:[]}):t}return t(".if block incorrect",i),r},r.tap=({args:a,data:n})=>{let i=a[0];return e(i)?i(n):t("give .tap a fn to send data to"),n},r.with=({args:a,data:i,a_chute:r})=>{let l=a;return r.with_received&&t("1 with per chute"),r.with_received=!0,1===l.length&&n(l[0])||t(".with accepts 1 object for settings"),l=l[0],l.sync&&function(a,n){e(a)||t('"sync" takes "v=>external_variable=v"');n.sync_data=a,n.sync_data(n.get_data())}(l.sync,r),l.skip_void&&(r.skip_void=!!l.skip_void),l.feed&&f(l.feed),l.lift&&d(l.lift),i};return o})();